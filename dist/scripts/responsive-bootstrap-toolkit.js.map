{"version":3,"sources":["../bower_components/responsive-bootstrap-toolkit/dist/bootstrap-toolkit.js"],"names":["ResponsiveBootstrapToolkit","$","internal","detectionDivs","bootstrap","xs","sm","md","lg","foundation","small","medium","large","xlarge","applyDetectionDivs","document","ready","each","self","breakpoints","alias","appendTo","isAnExpression","str","charAt","splitExpression","operator","orEqual","index","breakpointName","slice","isAnyActive","found","is","isMatchingExpression","expression","breakpointList","Object","keys","pos","indexOf","start","end","undefined","acceptedBreakpoints","interval","framework","use","frameworkName","toLowerCase","current","name","changed","fn","ms","timer","clearTimeout","setTimeout","jQuery"],"mappings":"AAOA,GAAAA,4BAAA,SAAAC,GAGA,GAAAC,IAKAC,eAEAC,WACAC,GAAAJ,EAAA,6DACAK,GAAAL,EAAA,6DACAM,GAAAN,EAAA,6DACAO,GAAAP,EAAA,8DAGAQ,YACAC,MAAAT,EAAA,qDACAU,OAAAV,EAAA,sDACAW,MAAAX,EAAA,qDACAY,OAAAZ,EAAA,wDAOAa,mBAAA,WACAb,EAAAc,UAAAC,MAAA,WACAf,EAAAgB,KAAAC,EAAAC,YAAA,SAAAC,GACAF,EAAAC,YAAAC,GAAAC,SAAA,sCAQAC,eAAA,SAAAC,GACA,MAAA,KAAAA,EAAAC,OAAA,IAAA,KAAAD,EAAAC,OAAA,IAMAC,gBAAA,SAAAF,GAGA,GAAAG,GAAAH,EAAAC,OAAA,GAEAG,EAAA,KAAAJ,EAAAC,OAAA,GAQAI,EAAA,GAAAD,EAAA,EAAA,GAMAE,EAAAN,EAAAO,MAAAF,EAEA,QACAF,SAAAA,EACAC,QAAAA,EACAE,eAAAA,IAOAE,YAAA,SAAAZ,GACA,GAAAa,IAAA,CAQA,OAPA/B,GAAAgB,KAAAE,EAAA,SAAAS,EAAAR,GAEA,MAAAF,GAAAC,YAAAC,GAAAa,GAAA,aACAD,GAAA,GACA,GAFA,SAKAA,GAMAE,qBAAA,SAAAX,GAEA,GAAAY,GAAAjC,EAAAuB,gBAAAF,GAGAa,EAAAC,OAAAC,KAAApB,EAAAC,aAGAoB,EAAAH,EAAAI,QAAAL,EAAAN,eAGA,IAAA,KAAAU,EAAA,CAEA,GAAAE,GAAA,EACAC,EAAA,CAWA,MAAAP,EAAAT,WACAe,EAAA,EACAC,EAAAP,EAAAR,UAAAY,EAAAA,GAWA,KAAAJ,EAAAT,WACAe,EAAAN,EAAAR,QAAAY,IAAAA,EACAG,EAAAC,OAGA,IAAAC,GAAAR,EAAAN,MAAAW,EAAAC,EAEA,OAAAxC,GAAA6B,YAAAa,MAQA1B,GAKA2B,SAAA,IAKAC,UAAA,KAKA3B,YAAA,KAKAc,GAAA,SAAAV,GACA,MAAArB,GAAAoB,eAAAC,GACArB,EAAAgC,qBAAAX,GAEAL,EAAAC,YAAAI,IAAAL,EAAAC,YAAAI,GAAAU,GAAA,aAMAc,IAAA,SAAAC,EAAA7B,GACAD,EAAA4B,UAAAE,EAAAC,cAEA,cAAA/B,EAAA4B,WAAA,eAAA5B,EAAA4B,UACA5B,EAAAC,YAAAjB,EAAAC,cAAAe,EAAA4B,WAEA5B,EAAAC,YAAAA,EAGAjB,EAAAY,sBAMAoC,QAAA,WACA,GAAAC,GAAA,cAMA,OALAlD,GAAAgB,KAAAC,EAAAC,YAAA,SAAAC,GACAF,EAAAe,GAAAb,KACA+B,EAAA/B,KAGA+B,GAMAC,QAAA,SAAAC,EAAAC,GACA,GAAAC,EACA,OAAA,YACAC,aAAAD,GACAA,EAAAE,WAAA,WACAJ,KACAC,GAAApC,EAAA2B,YAeA,OARA5C,GAAAc,UAAAC,MAAA,WACAf,EAAA,oDAAAoB,SAAA,UAGA,OAAAH,EAAA4B,WACA5B,EAAA6B,IAAA,aAGA7B,GAEAwC","file":"responsive-bootstrap-toolkit.js","sourcesContent":["/*!\n * Responsive Bootstrap Toolkit\n * Author:    Maciej Gurban\n * License:   MIT\n * Version:   2.5.1 (2015-11-02)\n * Origin:    https://github.com/maciej-gurban/responsive-bootstrap-toolkit\n */\n;var ResponsiveBootstrapToolkit = (function($){\n\n    // Internal methods\n    var internal = {\n\n        /**\n         * Breakpoint detection divs for each framework version\n         */\n        detectionDivs: {\n            // Bootstrap 3\n            bootstrap: {\n                'xs': $('<div class=\"device-xs visible-xs visible-xs-block\"></div>'),\n                'sm': $('<div class=\"device-sm visible-sm visible-sm-block\"></div>'),\n                'md': $('<div class=\"device-md visible-md visible-md-block\"></div>'),\n                'lg': $('<div class=\"device-lg visible-lg visible-lg-block\"></div>')\n            },\n            // Foundation 5\n            foundation: {\n                'small':  $('<div class=\"device-xs show-for-small-only\"></div>'),\n                'medium': $('<div class=\"device-sm show-for-medium-only\"></div>'),\n                'large':  $('<div class=\"device-md show-for-large-only\"></div>'),\n                'xlarge': $('<div class=\"device-lg show-for-xlarge-only\"></div>')\n            }\n        },\n\n         /**\n         * Append visibility divs after DOM laoded\n         */\n        applyDetectionDivs: function() {\n            $(document).ready(function(){\n                $.each(self.breakpoints, function(alias){\n                    self.breakpoints[alias].appendTo('.responsive-bootstrap-toolkit');\n                });\n            });\n        },\n\n        /**\n         * Determines whether passed string is a parsable expression\n         */\n        isAnExpression: function( str ) {\n            return (str.charAt(0) == '<' || str.charAt(0) == '>');\n        },\n\n        /**\n         * Splits the expression in into <|> [=] alias\n         */\n        splitExpression: function( str ) {\n\n            // Used operator\n            var operator = str.charAt(0);\n            // Include breakpoint equal to alias?\n            var orEqual  = (str.charAt(1) == '=') ? true : false;\n\n            /**\n             * Index at which breakpoint name starts.\n             *\n             * For:  >sm, index = 1\n             * For: >=sm, index = 2\n             */\n            var index = 1 + (orEqual ? 1 : 0);\n\n            /**\n             * The remaining part of the expression, after the operator, will be treated as the\n             * breakpoint name to compare with\n             */\n            var breakpointName = str.slice(index);\n\n            return {\n                operator:       operator,\n                orEqual:        orEqual,\n                breakpointName: breakpointName\n            };\n        },\n\n        /**\n         * Returns true if currently active breakpoint matches the expression\n         */\n        isAnyActive: function( breakpoints ) {\n            var found = false;\n            $.each(breakpoints, function( index, alias ) {\n                // Once first breakpoint matches, return true and break out of the loop\n                if( self.breakpoints[ alias ].is(':visible') ) {\n                    found = true;\n                    return false;\n                }\n            });\n            return found;\n        },\n\n        /**\n         * Determines whether current breakpoint matches the expression given\n         */\n        isMatchingExpression: function( str ) {\n\n            var expression = internal.splitExpression( str );\n\n            // Get names of all breakpoints\n            var breakpointList = Object.keys(self.breakpoints);\n\n            // Get index of sought breakpoint in the list\n            var pos = breakpointList.indexOf( expression.breakpointName );\n\n            // Breakpoint found\n            if( pos !== -1 ) {\n\n                var start = 0;\n                var end   = 0;\n\n                /**\n                 * Parsing viewport.is('<=md') we interate from smallest breakpoint ('xs') and end\n                 * at 'md' breakpoint, indicated in the expression,\n                 * That makes: start = 0, end = 2 (index of 'md' breakpoint)\n                 *\n                 * Parsing viewport.is('<md') we start at index 'xs' breakpoint, and end at\n                 * 'sm' breakpoint, one before 'md'.\n                 * Which makes: start = 0, end = 1\n                 */\n                if( expression.operator == '<' ) {\n                    start = 0;\n                    end   = expression.orEqual ? ++pos : pos;\n                }\n                /**\n                 * Parsing viewport.is('>=sm') we interate from breakpoint 'sm' and end at the end\n                 * of breakpoint list.\n                 * That makes: start = 1, end = undefined\n                 *\n                 * Parsing viewport.is('>sm') we start at breakpoint 'md' and end at the end of\n                 * breakpoint list.\n                 * Which makes: start = 2, end = undefined\n                 */\n                if( expression.operator == '>' ) {\n                    start = expression.orEqual ? pos : ++pos;\n                    end   = undefined;\n                }\n\n                var acceptedBreakpoints = breakpointList.slice(start, end);\n\n                return internal.isAnyActive( acceptedBreakpoints );\n\n            }\n        }\n\n    };\n\n    // Public methods and properties\n    var self = {\n\n        /**\n         * Determines default debouncing interval of 'changed' method\n         */\n        interval: 300,\n\n        /**\n         *\n         */\n        framework: null,\n\n        /**\n         * Breakpoint aliases, listed from smallest to biggest\n         */\n        breakpoints: null,\n\n        /**\n         * Returns true if current breakpoint matches passed alias\n         */\n        is: function( str ) {\n            if( internal.isAnExpression( str ) ) {\n                return internal.isMatchingExpression( str );\n            }\n            return self.breakpoints[ str ] && self.breakpoints[ str ].is(':visible');\n        },\n\n        /**\n         * Determines which framework-specific breakpoint detection divs to use\n         */\n        use: function( frameworkName, breakpoints ) {\n            self.framework = frameworkName.toLowerCase();\n\n            if( self.framework === 'bootstrap' || self.framework === 'foundation') {\n                self.breakpoints = internal.detectionDivs[ self.framework ];\n            } else {\n                self.breakpoints = breakpoints;\n            }\n\n            internal.applyDetectionDivs();\n        },\n\n        /**\n         * Returns current breakpoint alias\n         */\n        current: function(){\n            var name = 'unrecognized';\n            $.each(self.breakpoints, function(alias){\n                if (self.is(alias)) {\n                    name = alias;\n                }\n            });\n            return name;\n        },\n\n        /*\n         * Waits specified number of miliseconds before executing a callback\n         */\n        changed: function(fn, ms) {\n            var timer;\n            return function(){\n                clearTimeout(timer);\n                timer = setTimeout(function(){\n                    fn();\n                }, ms || self.interval);\n            };\n        }\n\n    };\n\n    // Create a placeholder\n    $(document).ready(function(){\n        $('<div class=\"responsive-bootstrap-toolkit\"></div>').appendTo('body');\n    });\n\n    if( self.framework === null ) {\n        self.use('bootstrap');\n    }\n\n    return self;\n\n})(jQuery);\n"],"sourceRoot":"assets/scripts/"}